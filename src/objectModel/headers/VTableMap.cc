
#include "Object.h"
#include "Nothing.h"


#ifndef PDBCATALOG_VTABLEMAP_C_
#define PDBCATALOG_VTABLEMAP_C_

/*
 * VTableMap.cc
 */

// This header is auto-generated by SConstruct... it includes all of the header files
// in BuiltInPDBObjects/headers

#include <dlfcn.h>
#include "PDBDebug.h"
#include "LockGuard.h"
#include <unistd.h>
#include "PDBLogger.h"
#include <cctype>
#include <ctime>
#include <sys/types.h>
#include <sys/stat.h>
#include <chrono>
#include <fcntl.h>

namespace pdb {

inline int16_t VTableMap::lookupBuiltInType(std::string objectTypeName) {
    if (theVTable->objectTypeNamesList.count(objectTypeName) != 0)
        if (theVTable->objectTypeNamesList[objectTypeName] >= 0 &&
            theVTable->objectTypeNamesList[objectTypeName] <= 8191)
            return theVTable->objectTypeNamesList[objectTypeName];

    // otherwise, return -1 to signify that this was not a built-in type
    return -1;
}

inline std::string VTableMap::lookupBuiltInType(int16_t objectType) {

    // loop through every type in the mape
    for (auto& a : theVTable->objectTypeNamesList) {
        if (a.second == objectType)
            return a.first;
    }

    // otherwise, return "" to signify that this was not a built-in type
    return "";
}

// returns the number of registered built-in objects
inline int VTableMap::totalBuiltInObjects() {
    int count = 0;
    for (unsigned int i = 0; i < theVTable->allVTables.size(); i++) {
        if (theVTable->allVTables[i] != nullptr) {
            count = count + 1;
        }
    }
    return count;
}

inline void VTableMap::listVtableEntries() {
    for (unsigned int i = 0; i < theVTable->allVTables.size(); i++) {
        if (theVTable->allVTables[i] != nullptr)
            PDB_COUT << "vtpr " << i << ": " << theVTable->allVTables[i] << std::endl;
    }
}

inline void VTableMap::listVtableLabels() {
    std::map<std::string, int16_t> iterator;

    for (auto& iterator : theVTable->objectTypeNamesList) {
        PDB_COUT << "Type name= " << iterator.first << " | TypeId= " << iterator.second
                  << std::endl;
    }
}

inline std::string VTableMap::getInternalTypeName(const std::string &realName) {

    // one important issue is that we might need to lookup soething nasty like:
    //
    // pdb::PairArray<pdb::Handle<pdb::String>,pdb::Handle<pdb::Employee>>
    //
    // this needs to be normalized to:
    //
    // pdb::PairArray<<pdb::Nothing>,<pdb::Nothing>?
    //
    // basically, we have a stack that pushes and pops the depth of the template by counting
    // instances of '>' and '<'
    // Any time that we see a "," at depth 1, it means we've hit an additional template arguement,
    // and so we add
    // a "<pdb::Nothing>" to the replacement string

    //First, let's handle exception 
    if (realName == std::string("pdb::EnsembleTreeGenericUDF<float>"))
	    return realName;

    if (realName == std::string("pdb::EnsembleTreeGenericUDF<double>"))
	    return std::string("pdb::EnsembleTreeGenericUDF<float>");

    std::string replacementString;
    std::string prefix;
    bool isTemplate = false;
    int depth = 0;
    auto length = realName.size();
    for (unsigned int loc = 0; loc < length; loc++) {
        if (realName[loc] == '<') {
            depth++;
            if (depth == 1) {
                isTemplate = true;
                prefix = realName.substr(0, loc);
                replacementString = std::string("pdb::Nothing");
            }
        } else if (realName[loc] == '>') {
            depth--;
        } else if (realName[loc] == ',' && depth == 1) {
            std::string nextReplacement(",pdb::Nothing");
            replacementString += nextReplacement;
        }
    }

    // if this was a template, do the normalization
    if (isTemplate) {
        return std::move(prefix + std::string("<") + replacementString + std::string(">"));
    } 

    return realName;
}





inline int16_t VTableMap::getIDByName(std::string objectTypeName, bool withLock) {

    // now, check to make sure that we have seen the given object type before
    if (theVTable->objectTypeNamesList.count(objectTypeName) == 0 &&
        theVTable->catalog != nullptr) {

        // make sure no one is modifying the map
        int16_t identifier;
        if (withLock) {
            const LockGuard guard{theVTable->myLock};
            // in this case, we do not have this object type, and we have never looked for it before
            // so, go to the catalog and ask for it...
            identifier = lookupTypeNameInCatalog(objectTypeName);
            // if the identifier is -1, then it means the catalog has never seen this type before
            // so let the caller know, and remember that we have not seen it
            if (identifier == -1) {
                theVTable->objectTypeNamesList[objectTypeName] = TYPE_NOT_RECOGNIZED;
                return TYPE_NOT_RECOGNIZED;
                // otherwise, return the ID
            } else {
                theVTable->objectTypeNamesList[objectTypeName] = identifier;
                return identifier;
            }
        } else {
            identifier = lookupTypeNameInCatalog(objectTypeName);
            // if the identifier is -1, then it means the catalog has never seen this type before
            // so let the caller know, and remember that we have not seen it
            if (identifier == -1) {
                theVTable->objectTypeNamesList[objectTypeName] = TYPE_NOT_RECOGNIZED;
                return TYPE_NOT_RECOGNIZED;
                // otherwise, return the ID
            } else {
                theVTable->objectTypeNamesList[objectTypeName] = identifier;
                return identifier;
            }
        }
    } else if (theVTable->objectTypeNamesList.count(objectTypeName) == 0) {
        // we don't know this type, and we have no catalog client
        theVTable->objectTypeNamesList[objectTypeName] = TYPE_NOT_RECOGNIZED;
        return TYPE_NOT_RECOGNIZED;
    } else {
        // in the easy case, we have seen it before, so just return the typeID
        int16_t identifier = theVTable->objectTypeNamesList[objectTypeName];
        PDB_COUT << "builtin, typeId for " << objectTypeName << " is " << identifier << std ::
           endl;
        return identifier;
    }


}

inline void VTableMap::setCatalogClient(CatalogClient* catalogIn) {
    const LockGuard guard{theVTable->myLock};

    theVTable->catalog = catalogIn;
}

inline CatalogClient* VTableMap::getCatalogClient() {
    const LockGuard guard{theVTable->myLock};
    CatalogClient* client = theVTable->catalog;
    return client;
}

extern bool inSharedLibrary;

inline VTableMap::~VTableMap() {
    const LockGuard guard{theVTable->myLock};
    std::string tag = "inSharedLibrary";
    if (!inSharedLibrary) {
        tag = "notInSharedLibrary";
        for (void* v : theVTable->so_handles) {
            int res = dlclose(v);
            if (res != 0)
                std::cout << dlerror() << "\n";
        }
    }
    theVTable->so_handles.clear();
}

inline void* VTableMap::getVTablePtr(int16_t objectTypeID) {

#ifdef DEBUG_VTABLE_FIXING
      auto fixStart = std::chrono::high_resolution_clock::now();
#endif
    // it could be a C++ type, we simply return nullptr
    if (objectTypeID < 0) {
        return nullptr;
    }

    // JIANOTE TODO: we may need lock it, otherwise another thread may change it
    /*
    // OK, first, we check to see if we have the v table pointer for this guy...
    // this is done without a lock, so we can be very fast...
    */
    void* returnVal = theVTable->allVTables[objectTypeID];
    if (returnVal != nullptr) {
        return returnVal;
    }

    const LockGuard guard{theVTable->myLock};
    // before we go out to the network for the v table pointer, just verify
    // that another thread has not since gotten it for us
    returnVal = theVTable->allVTables[objectTypeID];

    if (returnVal != nullptr) {
/*
#ifdef DEBUG_VTABLE_FIXING
       auto fixEnd = std::chrono::high_resolution_clock::now();
       theVTable->totalVTableFixingTime += std::chrono::duration_cast<std::chrono::nanoseconds>(fixEnd - fixStart).count();
       theVTable->numFixes ++;
       if (theVTable->numFixes == 10000) {
            theVTable->logger->error(
                    std::to_string(theVTable->numFixes)+":"+std::to_string(theVTable->totalVTableFixingTime));
            theVTable->numFixes = 0;
            theVTable->totalVTableFixingTime = 0;           
       }       
#endif
*/
        return returnVal;
    } else {
        // if they have not gotten it for us, then go and get it
        returnVal = getVTablePtrUsingCatalog(objectTypeID);
#ifdef DEBUG_VTABLE_FIXING
       auto fixEnd = std::chrono::high_resolution_clock::now();
       if (objectTypeID >= 8191) {
           double duration = std::chrono::duration_cast<std::chrono::nanoseconds>(fixEnd - fixStart).count();
           theVTable->numFixes ++;
           theVTable->logger->error(
               std::to_string(theVTable->numFixes)+","+std::to_string(objectTypeID)+","+std::to_string(duration));
       }
#endif
        return returnVal;
    }
}

inline std::vector<std::pair<std::string, int16_t>> pdb::VTableMap::getBuiltInTypes() {

  // make are return value
  std::vector<std::pair<std::string, int16_t>> ret;

  // got through each type and filter out the built in ones
  for (const auto &type : theVTable->objectTypeNamesList) {
    if (type.second >= 0 && type.second <= TYPE_NOT_RECOGNIZED) {
      ret.emplace_back(type);
    }
  }

  // i like to move it move it!
  return std::move(ret);
}



} /* namespace pdb */

#endif
